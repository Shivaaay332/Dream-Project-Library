<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ultimate Snake Game - Mobile Edition</title>
    <style>
        /* Permanent Dark Mode Variables */
        :root {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --canvas-border: #4CAF50; /* Green border for cool look */
            --canvas-bg: #1e1e1e;
            --snake-color: #00ff88;
            --food-color: #ff5252;
            --poison-color: #9c27b0;
            --wall-color: #888;
            --accent-color: #2196F3;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden;
            touch-action: none; /* Prevents page scrolling on swipe */
        }

        .header { text-align: center; margin-bottom: 15px; width: 95vmin; max-width: 400px; }
        
        .stats {
            display: flex; justify-content: space-between; gap: 10px; font-size: 1rem; font-weight: bold;
            background: rgba(255,255,255,0.05); padding: 12px; border-radius: 10px;
        }

        .powerup-status {
            height: 20px; color: var(--accent-color); font-weight: bold;
            font-size: 0.9rem; margin: 8px 0; letter-spacing: 1px;
        }

        /* Canvas Container for Overlays */
        .game-container { position: relative; }

        canvas {
            border: 3px solid var(--canvas-border);
            background-color: var(--canvas-bg);
            box-shadow: 0 10px 30px rgba(0,255,136,0.1); /* Glow effect */
            border-radius: 8px;
            /* Mobile Responsive Sizing */
            width: 95vmin;
            height: 95vmin;
            max-width: 400px;
            max-height: 400px;
        }

        /* Overlays (Start Screen & Pause) */
        .overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            width: 75%;
            max-width: 250px;
            z-index: 10;
            border: 1px solid #333;
        }

        .overlay h2 { margin-top: 0; color: #00ff88; font-size: 1.5rem; }
        .overlay p { font-size: 0.85rem; color: #ccc; margin-bottom: 20px; line-height: 1.5; }

        .btn-large {
            padding: 14px 24px;
            font-size: 1.1rem;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .btn-large:active { transform: scale(0.95); background: #45a049; }

        .help-text {
            font-size: 0.8rem; opacity: 0.6; margin-top: 20px; text-align: center; line-height: 1.6;
        }

    </style>
</head>
<body>

    <div class="header">
        <div class="stats">
            <div>Score: <span id="score">0</span></div>
            <div>High: <span id="highScore">0</span></div>
            <div>Level: <span id="level">1</span></div>
        </div>
        <div class="powerup-status" id="powerUpStatus"></div>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        
        <div id="startScreen" class="overlay">
            <h2>üêç SNAKE PRO</h2>
            <p>üçé Eat Food (+1)<br>‚ò†Ô∏è Avoid Poison (-5)<br>‚ö° Catch Powerups</p>
            <button class="btn-large" onclick="startGame()">‚ñ∂ PLAY</button>
        </div>

        <div id="pauseOverlay" class="overlay" style="display: none;">
            <h2>‚è∏Ô∏è PAUSED</h2>
            <p>Tap anywhere to Resume</p>
            <button class="btn-large" onclick="togglePause()">RESUME</button>
        </div>
    </div>
    
    <p class="help-text">
        üëÜ Swipe to Move ‚Ä¢ Tap to Pause<br>
        Ghost üëª ‚Ä¢ Slow üê¢ ‚Ä¢ 2X ‚ö°
    </p>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const highScoreEl = document.getElementById("highScore");
        const levelEl = document.getElementById("level");
        const powerUpStatusEl = document.getElementById("powerUpStatus");
        const pauseOverlay = document.getElementById("pauseOverlay");
        const startScreen = document.getElementById("startScreen");

        const gridSize = 20;
        const tileCount = canvas.width / gridSize;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        let snake = [];
        let velocity = { x: 0, y: 0 };
        let food = { x: 5, y: 5, type: 'normal' };
        let poison = null;
        let powerUp = null;
        let obstacles = [];
        let particles = [];
        let score = 0;
        let highScore = localStorage.getItem('snakeProHighScore') || 0;
        highScoreEl.innerText = highScore;

        let baseSpeed = 250; 
        let speed = baseSpeed;
        
        let gameInterval;
        let isRunning = false;
        let isPaused = false;
        let level = 1;
        let activeEffect = { type: null, timer: null, endTime: 0 };
        let scoreMultiplier = 1;

        // Initial Draw (Blank Board)
        ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--canvas-bg');
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // --- Game Functions ---

        function startGame() {
            // Unlock AudioContext for mobile browsers
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            startScreen.style.display = 'none';
            initGame();
        }

        function initGame() {
            snake = [{x: 10, y: 10}, {x: 9, y: 10}, {x: 8, y: 10}];
            velocity = { x: 1, y: 0 };
            score = 0;
            level = 1;
            scoreMultiplier = 1;
            
            baseSpeed = 250; 
            speed = baseSpeed;
            
            poison = null;
            powerUp = null;
            particles = [];
            clearEffect();
            
            updateUI();
            generateObstacles();
            spawnItem('food');
            
            if (gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(gameLoop, speed);
            isRunning = true;
            isPaused = false;
            pauseOverlay.style.display = 'none';
        }

        function gameLoop() {
            if (isPaused) return;
            update();
            draw();
            if (activeEffect.type && Date.now() > activeEffect.endTime) clearEffect();
        }

        function update() {
            particles.forEach((p, index) => {
                p.x += p.vx; p.y += p.vy; p.life -= 0.05;
                if(p.life <= 0) particles.splice(index, 1);
            });

            const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

            // Wall/Obstacle Collision
            if (activeEffect.type === 'ghost') {
                if (head.x < 0) head.x = tileCount - 1; if (head.x >= tileCount) head.x = 0;
                if (head.y < 0) head.y = tileCount - 1; if (head.y >= tileCount) head.y = 0;
            } else {
                if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) { gameOver(); return; }
                if (isCollidingWithObstacle(head)) { gameOver(); return; }
            }

            // Self Collision
            for (let part of snake) { if (head.x === part.x && head.y === part.y) { gameOver(); return; } }

            snake.unshift(head);

            // Collisions
            if (head.x === food.x && head.y === food.y) {
                let points = (food.type === 'gold' ? 5 : 1) * scoreMultiplier;
                score += points;
                createParticles(head.x, head.y, food.type === 'gold' ? '#FFD700' : '#FF5252');
                playSound('eat');
                
                let nextType = (score % 5 === 0) ? 'gold' : 'normal';
                spawnItem('food', nextType);
                if (Math.random() < 0.3) spawnItem('poison');
                if (Math.random() < 0.1) spawnItem('powerup');
                checkLevelUp();
            } else {
                snake.pop();
            }

            if (poison && head.x === poison.x && head.y === poison.y) {
                score = Math.max(0, score - 5);
                createParticles(head.x, head.y, '#9c27b0');
                playSound('poison');
                poison = null;
                if (snake.length > 3) snake.pop();
            }

            if (powerUp && head.x === powerUp.x && head.y === powerUp.y) {
                activatePowerUp(powerUp.type);
                createParticles(head.x, head.y, '#2196F3');
                playSound('powerup');
                powerUp = null;
            }
            updateUI();
        }

        // --- Helpers ---
        function activatePowerUp(type) {
            clearEffect();
            activeEffect.type = type;
            activeEffect.endTime = Date.now() + 5000;
            if (type === 'ghost') powerUpStatusEl.innerText = "üëª GHOST MODE";
            else if (type === 'slow') {
                powerUpStatusEl.innerText = "üê¢ SLOW MOTION";
                clearInterval(gameInterval);
                gameInterval = setInterval(gameLoop, speed * 1.5);
            } else if (type === 'double') {
                powerUpStatusEl.innerText = "‚ö° 2X POINTS";
                scoreMultiplier = 2;
            }
        }

        function clearEffect() {
            activeEffect.type = null;
            scoreMultiplier = 1;
            powerUpStatusEl.innerText = "";
            clearInterval(gameInterval);
            if(isRunning && !isPaused) gameInterval = setInterval(gameLoop, speed);
        }

        function checkLevelUp() {
            const newLevel = Math.floor(score / 15) + 1;
            if (newLevel > level) {
                level = newLevel;
                baseSpeed = Math.max(100, baseSpeed - 15); 
                speed = baseSpeed;
                generateObstacles();
                playSound('levelup');
                powerUpStatusEl.innerText = `LEVEL ${level}!`;
                setTimeout(() => { if(!activeEffect.type) powerUpStatusEl.innerText = ""; }, 2000);
            }
        }

        function generateObstacles() {
            obstacles = [];
            if (level === 1) return;
            if (level >= 2) for (let i = 5; i < 15; i++) obstacles.push({x: i, y: 10});
            if (level >= 3) {
                obstacles.push({x: 5, y: 5}, {x: 5, y: 6}, {x: 6, y: 5});
                obstacles.push({x: 15, y: 5}, {x: 15, y: 6}, {x: 14, y: 5});
            }
            if (level >= 4) {
                for(let i=0; i<level; i++) obstacles.push({
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                });
            }
        }

        function spawnItem(category, subType = 'normal') {
            let item = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
            if (isOccupied(item)) return spawnItem(category, subType);
            
            if (category === 'food') food = { ...item, type: subType };
            else if (category === 'poison') { poison = item; setTimeout(() => poison = null, 8000); }
            else if (category === 'powerup') {
                const types = ['ghost', 'slow', 'double'];
                powerUp = { ...item, type: types[Math.floor(Math.random() * types.length)] };
            }
        }

        function isOccupied(pos) {
            for (let part of snake) if (part.x === pos.x && part.y === pos.y) return true;
            if (isCollidingWithObstacle(pos)) return true;
            if (food.x === pos.x && food.y === pos.y) return true;
            return false;
        }

        function isCollidingWithObstacle(pos) {
            for (let obs of obstacles) if (obs.x === pos.x && obs.y === pos.y) return true;
            return false;
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x, y: y, vx: (Math.random() - 0.5) * 0.5, vy: (Math.random() - 0.5) * 0.5, life: 1.0, color: color
                });
            }
        }

        function draw() {
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--canvas-bg');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--wall-color');
            for (let obs of obstacles) ctx.fillRect(obs.x * gridSize, obs.y * gridSize, gridSize-2, gridSize-2);

            ctx.fillStyle = (food.type === 'gold') ? '#FFD700' : getComputedStyle(document.body).getPropertyValue('--food-color');
            if (food.type === 'gold') { ctx.beginPath(); ctx.arc((food.x*gridSize)+10, (food.y*gridSize)+10, 8, 0, Math.PI*2); ctx.fill(); }
            else ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize-2, gridSize-2);

            if (poison) {
                ctx.fillStyle = '#9c27b0'; ctx.beginPath();
                ctx.moveTo((poison.x*gridSize)+10, poison.y*gridSize);
                ctx.lineTo((poison.x*gridSize)+20, (poison.y*gridSize)+20);
                ctx.lineTo(poison.x*gridSize, (poison.y*gridSize)+20); ctx.fill();
            }

            if (powerUp) {
                ctx.fillStyle = '#2196F3'; ctx.font = '16px Arial';
                let icon = powerUp.type === 'ghost' ? 'üëª' : (powerUp.type === 'slow' ? 'üê¢' : '‚ö°');
                ctx.fillText(icon, powerUp.x * gridSize, (powerUp.y * gridSize) + 16);
            }

            for (let i = 0; i < snake.length; i++) {
                ctx.fillStyle = (activeEffect.type === 'ghost') ? 'rgba(0, 255, 136, 0.4)' : getComputedStyle(document.body).getPropertyValue('--snake-color');
                // Give head a slightly different color
                if(i === 0 && activeEffect.type !== 'ghost') ctx.fillStyle = '#ffffff'; 
                ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize-2, gridSize-2);
            }

            for (let p of particles) {
                ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
                ctx.fillRect(p.x * gridSize, p.y * gridSize, gridSize/3, gridSize/3);
            }
            ctx.globalAlpha = 1.0;
        }

        function togglePause() {
            if (!isRunning) return;
            isPaused = !isPaused;
            pauseOverlay.style.display = isPaused ? 'block' : 'none';
        }

        function resetGame() {
            isRunning = false;
            clearInterval(gameInterval);
            startScreen.style.display = 'block'; 
            pauseOverlay.style.display = 'none';
        }

        function gameOver() {
            isRunning = false;
            clearInterval(gameInterval);
            playSound('die');
            if (score > highScore) { highScore = score; localStorage.setItem('snakeProHighScore', highScore); }
            // Custom game over display logic instead of alert
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.font = "30px Arial";
            ctx.textAlign = "center";
            ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2 - 20);
            ctx.font = "20px Arial";
            ctx.fillText(`Score: ${score}`, canvas.width/2, canvas.height/2 + 20);
            
            setTimeout(resetGame, 2000); // Back to menu after 2 seconds
        }

        function updateUI() {
            scoreEl.innerText = score; highScoreEl.innerText = highScore; levelEl.innerText = level;
        }

        // --- Inputs ---
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') { togglePause(); return; }
            if (!isRunning || isPaused) return;
            switch (e.key) {
                case 'ArrowUp': if(velocity.y !== 1) velocity = {x: 0, y: -1}; break;
                case 'ArrowDown': if(velocity.y !== -1) velocity = {x: 0, y: 1}; break;
                case 'ArrowLeft': if(velocity.x !== 1) velocity = {x: -1, y: 0}; break;
                case 'ArrowRight': if(velocity.x !== -1) velocity = {x: 1, y: 0}; break;
            }
        });

        // Mobile Touch & Swipe Logic
        let tsX = 0, tsY = 0;
        canvas.addEventListener('touchstart', e => { 
            tsX=e.changedTouches[0].screenX; 
            tsY=e.changedTouches[0].screenY; 
            e.preventDefault(); 
        }, {passive: false});

        canvas.addEventListener('touchend', e => {
            if(isPaused) { togglePause(); return; }
            let teX=e.changedTouches[0].screenX, teY=e.changedTouches[0].screenY;
            let dx = teX - tsX, dy = teY - tsY;
            
            // If the swipe is very small, treat it as a tap to Pause
            if (Math.abs(dx) < 15 && Math.abs(dy) < 15) {
                togglePause();
                return;
            }

            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0 && velocity.x !== -1) velocity = {x: 1, y: 0};
                else if (dx < 0 && velocity.x !== 1) velocity = {x: -1, y: 0};
            } else {
                if (dy > 0 && velocity.y !== -1) velocity = {x: 0, y: 1};
                else if (dy < 0 && velocity.y !== 1) velocity = {x: 0, y: -1};
            }
        }, {passive: false});

        // Sounds Logic
        function playSound(type) {
            if (audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            if (type === 'eat') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(440, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'die') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                osc.start(); osc.stop(audioCtx.currentTime + 0.5);
            } else if (type === 'powerup') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'poison') {
                osc.type = 'square'; osc.frequency.setValueAtTime(150, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            } else if (type === 'levelup') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                osc.frequency.linearRampToValueAtTime(400, audioCtx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            }
        }
    </script>
</body>
</html>
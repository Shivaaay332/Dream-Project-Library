<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Master Sudoku - Mobile Dark Edition</title>
    <style>
        :root {
            /* Forced Dark (Neon) Mode Variables */
            --bg-color: #0f172a;
            --board-bg: #1e293b;
            --text-color: #e2e8f0;
            --accent-color: #38bdf8;
            --grid-line: #334155;
            --grid-line-thick: #94a3b8;
            --cell-hover: #1e3a8a;
            --cell-selected: #0ea5e9;
            --cell-related: #1e293b;
            --error-color: #f43f5e;
            --success-color: #10b981;
            --note-color: #94a3b8;
            --btn-bg: #334155;
            --font-main: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        * { 
            box-sizing: border-box; 
            touch-action: manipulation; 
            -webkit-tap-highlight-color: transparent; /* Removes blue tap highlight on mobile */
        }
        
        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-evenly; /* Better spacing for mobile */
            height: 100dvh; /* Mobile friendly viewport height */
            margin: 0;
            overflow: hidden; /* Prevents scroll */
            padding: 10px 0;
        }

        /* --- Header & Stats --- */
        .header {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 20px;
        }

        h1 { margin: 0; font-size: 26px; font-weight: 800; letter-spacing: -1px; }

        .header select {
            padding: 8px 12px;
            border-radius: 8px;
            background: var(--btn-bg);
            color: var(--text-color);
            border: 1px solid var(--grid-line-thick);
            font-size: 14px;
            outline: none;
        }

        .stats-bar {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-between;
            padding: 0 20px 10px;
            font-size: 14px;
            font-weight: 600;
        }

        .stat-item span { color: var(--accent-color); margin-left: 5px; }

        /* --- Game Board --- */
        .game-board {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 96vw; /* Optimized for mobile width */
            max-width: 420px;
            aspect-ratio: 1/1;
            background: var(--grid-line-thick);
            gap: 1px;
            border: 2px solid var(--grid-line-thick);
            margin: 10px auto;
        }

        .cell {
            background: var(--board-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(16px, 6vw, 26px); /* Responsive font size */
            font-weight: 500;
            cursor: pointer;
            position: relative;
            user-select: none;
            transition: background 0.1s;
        }

        /* Thicker Borders for 3x3 grids */
        .cell:nth-child(3n) { border-right: 2px solid var(--grid-line-thick); }
        .cell:nth-child(9n) { border-right: none; }
        .cell:nth-child(n+19):nth-child(-n+27),
        .cell:nth-child(n+46):nth-child(-n+54) { border-bottom: 2px solid var(--grid-line-thick); }
        
        /* Dynamic Styles */
        .cell.selected { background: var(--cell-selected) !important; color: #fff; }
        .cell.related { background: var(--cell-hover); }
        .cell.highlight { background: var(--cell-related); color: var(--accent-color); font-weight: bold; }
        .cell.fixed { font-weight: bold; color: var(--text-color); pointer-events: none; }
        .cell.error { background: var(--error-color) !important; color: white; animation: shake 0.3s; }
        .cell.filled { color: var(--accent-color); }
        
        /* Notes Grid inside Cell */
        .notes-grid {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            pointer-events: none;
        }
        .note-num {
            font-size: clamp(8px, 2vw, 11px);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--note-color);
        }

        /* --- Controls --- */
        .controls {
            width: 100%;
            max-width: 500px;
            padding: 10px 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .numpad {
            display: flex;
            justify-content: space-between;
            gap: 4px;
        }

        .num-btn {
            flex: 1;
            height: 55px; /* Taller for mobile tapping */
            font-size: 24px;
            border: none;
            background: var(--btn-bg);
            color: var(--accent-color);
            cursor: pointer;
            border-radius: 8px;
            font-weight: 700;
        }
        .num-btn:active { transform: scale(0.95); background: var(--cell-hover); }

        .tools {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .tool-btn {
            padding: 12px 5px;
            border: none;
            border-radius: 12px;
            background: var(--btn-bg);
            color: var(--text-color);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            transition: transform 0.1s;
        }

        .tool-btn:active { transform: scale(0.95); }
        .tool-btn.active { background: var(--accent-color); color: #fff; }
        
        .icon { font-size: 20px; }

        /* --- Overlay --- */
        .overlay {
            position: fixed;
            top:0; left:0; width:100%; height:100%;
            background: rgba(15, 23, 42, 0.9); /* Matching dark theme overlay */
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
        }
        .overlay h2 { color: white; font-size: 32px; margin-bottom: 20px; text-align: center; }
        .overlay button {
            padding: 14px 40px;
            font-size: 18px;
            font-weight: bold;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 30px;
            cursor: pointer;
        }

        /* Animations */
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }

    </style>
</head>
<body>

    <div class="header">
        <h1>Sudoku</h1>
        <select id="diff-select" onchange="startGame()">
            <option value="30">Easy</option>
            <option value="40">Medium</option>
            <option value="50">Hard</option>
        </select>
    </div>

    <div class="stats-bar">
        <div class="stat-item">Mistakes: <span id="mistakes">0/3</span></div>
        <div class="stat-item">Time: <span id="timer">00:00</span></div>
        <div class="stat-item">Score: <span id="score">0</span></div>
    </div>

    <div class="game-board" id="board">
        </div>

    <div class="controls">
        <div class="numpad">
            <button class="num-btn" onclick="handleInput(1)">1</button>
            <button class="num-btn" onclick="handleInput(2)">2</button>
            <button class="num-btn" onclick="handleInput(3)">3</button>
            <button class="num-btn" onclick="handleInput(4)">4</button>
            <button class="num-btn" onclick="handleInput(5)">5</button>
            <button class="num-btn" onclick="handleInput(6)">6</button>
            <button class="num-btn" onclick="handleInput(7)">7</button>
            <button class="num-btn" onclick="handleInput(8)">8</button>
            <button class="num-btn" onclick="handleInput(9)">9</button>
        </div>

        <div class="tools">
            <button class="tool-btn" onclick="undo()">
                <span class="icon">‚Ü©Ô∏è</span> Undo
            </button>
            <button class="tool-btn" onclick="erase()">
                <span class="icon">üßπ</span> Erase
            </button>
            <button class="tool-btn" id="note-btn" onclick="toggleNotes()">
                <span class="icon">‚úèÔ∏è</span> <div style="line-height:1.2">Notes <br><span style="font-size:10px">(Off)</span></div>
            </button>
            <button class="tool-btn" onclick="getHint()">
                <span class="icon">üí°</span> Hint
            </button>
        </div>
    </div>

    <div class="overlay" id="game-over-modal">
        <h2 id="modal-title">Game Over</h2>
        <button onclick="startGame()">New Game</button>
    </div>

    <script>
        // --- Game State ---
        let boardState = [];
        let solutionState = [];
        let fixedCells = []; // Indices of initial numbers
        let notesState = []; // Array of arrays for notes
        let history = []; // Undo stack
        let selectedCellIndex = -1;
        let mistakes = 0;
        let isNoteMode = false;
        let timerInterval;
        let timeElapsed = 0;
        let score = 0;

        // --- Initialization ---
        function startGame() {
            // Reset Variables
            mistakes = 0;
            timeElapsed = 0;
            score = 0;
            history = [];
            selectedCellIndex = -1;
            isNoteMode = false;
            
            const noteBtn = document.getElementById('note-btn');
            noteBtn.classList.remove('active');
            noteBtn.querySelector('span:last-child').innerText = "(Off)";
            
            document.getElementById('mistakes').innerText = "0/3";
            document.getElementById('game-over-modal').style.display = 'none';
            
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);

            // Generate Board
            generateSudoku();
            renderBoard();
        }

        // --- Sudoku Generator (Backtracking) ---
        function generateSudoku() {
            // 1. Create Empty 9x9
            solutionState = Array(81).fill(0);
            
            // 2. Fill diagonal 3x3 boxes (independent)
            fillDiagonal();
            
            // 3. Solve the rest
            solveSudoku(solutionState);
            
            // 4. Remove Digits to create puzzle
            boardState = [...solutionState];
            fixedCells = Array(81).fill(false);
            notesState = Array(81).fill().map(() => []);

            const difficulty = parseInt(document.getElementById('diff-select').value);
            let attempts = difficulty;
            
            while(attempts > 0) {
                let idx = Math.floor(Math.random() * 81);
                if(boardState[idx] !== 0) {
                    boardState[idx] = 0;
                    attempts--;
                }
            }

            // Mark fixed cells
            for(let i=0; i<81; i++) {
                if(boardState[i] !== 0) fixedCells[i] = true;
            }
        }

        function fillDiagonal() {
            for (let i = 0; i < 9; i = i + 3) {
                fillBox(i, i);
            }
        }

        function fillBox(row, col) {
            let num;
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    do {
                        num = Math.floor(Math.random() * 9) + 1;
                    } while (!isSafeInBox(row, col, num));
                    solutionState[(row + i) * 9 + (col + j)] = num;
                }
            }
        }

        function isSafeInBox(rowStart, colStart, num) {
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (solutionState[(rowStart + i) * 9 + (colStart + j)] === num) return false;
                }
            }
            return true;
        }

        function solveSudoku(board) {
            for (let i = 0; i < 81; i++) {
                if (board[i] === 0) {
                    for (let num = 1; num <= 9; num++) {
                        if (isValid(board, i, num)) {
                            board[i] = num;
                            if (solveSudoku(board)) return true;
                            board[i] = 0;
                        }
                    }
                    return false;
                }
            }
            return true;
        }

        function isValid(board, index, num) {
            const row = Math.floor(index / 9);
            const col = index % 9;
            const startRow = row - row % 3;
            const startCol = col - col % 3;

            for (let i = 0; i < 9; i++) {
                if (board[row * 9 + i] === num) return false; // Row
                if (board[i * 9 + col] === num) return false; // Col
            }
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (board[(startRow + i) * 9 + (startCol + j)] === num) return false; // Subgrid
                }
            }
            return true;
        }

        // --- Rendering ---
        function renderBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            for(let i=0; i<81; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                
                // Add Content
                if(boardState[i] !== 0) {
                    cell.innerText = boardState[i];
                    if(fixedCells[i]) cell.classList.add('fixed');
                    else cell.classList.add('filled');
                } else {
                    // Render Notes
                    const noteGrid = document.createElement('div');
                    noteGrid.classList.add('notes-grid');
                    for(let n=1; n<=9; n++) {
                        const noteSpan = document.createElement('span');
                        noteSpan.classList.add('note-num');
                        if(notesState[i].includes(n)) noteSpan.innerText = n;
                        noteGrid.appendChild(noteSpan);
                    }
                    cell.appendChild(noteGrid);
                }

                cell.onclick = () => selectCell(i);
                boardEl.appendChild(cell);
            }
        }

        // --- Interaction ---
        function selectCell(index) {
            if(selectedCellIndex !== -1) {
                document.querySelectorAll('.cell')[selectedCellIndex].classList.remove('selected');
            }
            selectedCellIndex = index;
            
            // Highlight logic
            const cells = document.querySelectorAll('.cell');
            cells.forEach(c => {
                c.classList.remove('selected', 'related', 'highlight');
            });

            const currentCell = cells[index];
            currentCell.classList.add('selected');

            // Highlight related rows/cols/box
            const row = Math.floor(index / 9);
            const col = index % 9;
            const val = boardState[index];

            for(let i=0; i<81; i++) {
                const r = Math.floor(i / 9);
                const c = i % 9;
                
                // Highlight same number
                if(val !== 0 && boardState[i] === val) {
                    cells[i].classList.add('highlight');
                }
                
                // Highlight related cells (row, col, box)
                if(r === row || c === col) cells[i].classList.add('related');
            }
        }

        function handleInput(num) {
            if(selectedCellIndex === -1) return;
            if(fixedCells[selectedCellIndex]) return;

            const cell = document.querySelectorAll('.cell')[selectedCellIndex];

            // NOTE MODE
            if(isNoteMode) {
                if(boardState[selectedCellIndex] !== 0) return; // Can't add notes to filled cell
                
                const notes = notesState[selectedCellIndex];
                if(notes.includes(num)) {
                    notesState[selectedCellIndex] = notes.filter(n => n !== num);
                } else {
                    notes.push(num);
                }
                renderBoard();
                selectCell(selectedCellIndex);
                return;
            }

            // NORMAL MODE
            // Check correctness
            if(num === solutionState[selectedCellIndex]) {
                // Correct
                const prevVal = boardState[selectedCellIndex];
                boardState[selectedCellIndex] = num;
                notesState[selectedCellIndex] = []; // Clear notes
                
                history.push({index: selectedCellIndex, prev: prevVal, type: 'fill'});
                
                renderBoard();
                selectCell(selectedCellIndex);
                checkWin();
            } else {
                // Wrong
                mistakes++;
                document.getElementById('mistakes').innerText = `${mistakes}/3`;
                cell.classList.add('error');
                setTimeout(() => cell.classList.remove('error'), 500);
                
                if(mistakes >= 3) {
                    gameOver(false);
                }
            }
        }

        // --- Tools ---
        function undo() {
            if(history.length === 0) return;
            const action = history.pop();
            
            if(action.type === 'fill') {
                boardState[action.index] = action.prev;
                renderBoard();
                selectCell(action.index);
            }
        }

        function erase() {
            if(selectedCellIndex === -1 || fixedCells[selectedCellIndex]) return;
            
            if(boardState[selectedCellIndex] !== 0) {
                history.push({index: selectedCellIndex, prev: boardState[selectedCellIndex], type: 'fill'});
                boardState[selectedCellIndex] = 0;
            } else {
                notesState[selectedCellIndex] = [];
            }
            renderBoard();
            selectCell(selectedCellIndex);
        }

        function toggleNotes() {
            isNoteMode = !isNoteMode;
            const btn = document.getElementById('note-btn');
            if(isNoteMode) {
                btn.classList.add('active');
                btn.querySelector('span:last-child').innerText = "(On)";
            } else {
                btn.classList.remove('active');
                btn.querySelector('span:last-child').innerText = "(Off)";
            }
        }

        function getHint() {
            if(selectedCellIndex === -1 || boardState[selectedCellIndex] !== 0) {
                // Find first empty cell if none selected or current filled
                selectedCellIndex = boardState.findIndex(val => val === 0);
                if(selectedCellIndex === -1) return;
                selectCell(selectedCellIndex);
            }

            const correctVal = solutionState[selectedCellIndex];
            handleInput(correctVal); // Reuse input logic to fill it
        }

        // --- System ---
        function updateTimer() {
            timeElapsed++;
            const mins = Math.floor(timeElapsed / 60).toString().padStart(2, '0');
            const secs = (timeElapsed % 60).toString().padStart(2, '0');
            document.getElementById('timer').innerText = `${mins}:${secs}`;
        }

        function checkWin() {
            if(!boardState.includes(0)) {
                gameOver(true);
            }
        }

        function gameOver(win) {
            clearInterval(timerInterval);
            const modal = document.getElementById('game-over-modal');
            const title = document.getElementById('modal-title');
            modal.style.display = 'flex';
            
            if(win) {
                title.innerText = "You Won! üéâ";
                title.style.color = "#10b981";
            } else {
                title.innerText = "Game Over ‚ùå";
                title.style.color = "#f43f5e";
            }
        }

        // Initialize Keyboard Support
        window.addEventListener('keydown', (e) => {
            if(e.key >= '1' && e.key <= '9') handleInput(parseInt(e.key));
            if(e.key === 'Backspace' || e.key === 'Delete') erase();
            if(e.key === 'n') toggleNotes();
            if(e.key === 'u') undo();
            if(e.key === 'h') getHint();
            
            // Arrows to move selection
            if(selectedCellIndex !== -1) {
                let r = Math.floor(selectedCellIndex / 9);
                let c = selectedCellIndex % 9;
                if(e.key === "ArrowUp") r = Math.max(0, r-1);
                if(e.key === "ArrowDown") r = Math.min(8, r+1);
                if(e.key === "ArrowLeft") c = Math.max(0, c-1);
                if(e.key === "ArrowRight") c = Math.min(8, c+1);
                selectCell(r*9 + c);
            }
        });

        // Start
        window.onload = startGame;

    </script>
</body>
</html>
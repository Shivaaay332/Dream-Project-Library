<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Waves - Expert Mode</title>
    <style>
        body { 
            margin: 0; 
            background: #050505; 
            color: white; 
            font-family: 'Arial', sans-serif; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh;
            /* Mobile par extra zoom aur scroll rokne ke liye */
            touch-action: none; 
            user-select: none; 
            -webkit-user-select: none;
        }
        canvas { 
            background: #000; 
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); 
            display: block;
        }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; pointer-events: none; z-index: 5; }
        .score-container { display: flex; justify-content: center; gap: 30px; }
        .stat { font-size: 1.5rem; font-weight: bold; color: #00ffff; text-shadow: 0 0 10px #00ffff; }
        #high-score { color: #ff00ff; text-shadow: 0 0 10px #ff00ff; }
        
        #overlay { position: absolute; background: rgba(0,0,0,0.85); width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 10; text-align: center; }
        #pause-overlay { position: absolute; color: yellow; font-size: 4rem; font-weight: bold; display: none; text-shadow: 0 0 20px orange; pointer-events: none; z-index: 20; }
        
        /* Restart Message Style */
        #restart-msg { 
            margin-top: 15px; 
            font-size: 1.5rem; 
            color: #00ff00; 
            animation: blink 1s infinite; 
            display: none; 
        }
        
        @keyframes blink { 50% { opacity: 0; } }
        b { color: #fff; background: #333; padding: 2px 6px; border-radius: 4px; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="score-container">
            <div class="stat">Score: <span id="dist">0</span></div>
            <div class="stat">Best: <span id="high-score">0</span></div>
        </div>
    </div>

    <div id="pause-overlay">PAUSED</div>

    <div id="overlay">
        <h1 id="main-title" style="color: #00ffff; font-size: 3.5rem; margin-bottom: 10px; text-shadow: 0 0 15px #00ffff;">SPACE WAVES</h1>
        <p id="start-msg" style="color: #eee; font-size: 1.3rem;">Press <b>SPACE</b> or <b>TAP</b> to Start</p>
        <div id="restart-msg">TAP OR PRESS SPACE TO RESTART</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const distEl = document.getElementById('dist');
        const highScoreEl = document.getElementById('high-score');
        const overlay = document.getElementById('overlay');
        const pauseOverlay = document.getElementById('pause-overlay');
        const mainTitle = document.getElementById('main-title');
        const startMsg = document.getElementById('start-msg');
        const restartMsg = document.getElementById('restart-msg');

        // Responsive Canvas Setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const WALL_HEIGHT = 40;
        let gameActive = false;
        let isPaused = false;
        let inputLocked = false; 
        
        let score = 0;
        let highScore = localStorage.getItem('spaceWavesHighscore') || 0;
        highScoreEl.innerText = highScore;

        let speed = 5;
        let obstacles = [];
        let particles = [];
        let frameCount = 0;

        const player = {
            x: window.innerWidth * 0.15 > 150 ? 150 : window.innerWidth * 0.15, // Better start position for mobile
            y: canvas.height / 2, size: 12, dy: 0, isHolding: false, color: '#00ffff'
        };

        // --- Sound Effects System (Web Audio API) ---
        let audioCtx;
        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            if (type === 'score') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'crash') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.5);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.5);
            } else if (type === 'start') {
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.2);
            }
        }

        // --- Input Handling (PC + Mobile) ---
        function handleInputStart(e) {
            // Prevent default behavior for game keys and touch to avoid scrolling
            if (e.type === 'keydown' && !['Space', 'ArrowUp', 'ArrowDown', 'Enter', 'KeyP'].includes(e.code)) return;
            if (e.type !== 'mousedown') e.preventDefault(); 
            
            initAudio(); // Required by browsers to start audio context on first interaction

            if (e.code === 'KeyP' && gameActive) {
                togglePause();
                return;
            }

            if (!gameActive && !inputLocked) {
                startGame();
                return;
            }

            if (gameActive && !isPaused) {
                player.isHolding = true;
            }
        }

        function handleInputEnd(e) {
            if (e.type === 'keyup' && !['Space', 'ArrowUp'].includes(e.code)) return;
            player.isHolding = false;
        }

        // Listeners for PC
        window.addEventListener('keydown', handleInputStart);
        window.addEventListener('keyup', handleInputEnd);
        
        // Listeners for Mobile / Mouse
        window.addEventListener('touchstart', handleInputStart, {passive: false});
        window.addEventListener('touchend', handleInputEnd);
        window.addEventListener('mousedown', handleInputStart);
        window.addEventListener('mouseup', handleInputEnd);

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) pauseOverlay.style.display = 'block';
            else { pauseOverlay.style.display = 'none'; update(); }
        }

        function startGame() {
            playSound('start');
            gameActive = true;
            isPaused = false;
            overlay.style.display = 'none';
            pauseOverlay.style.display = 'none';
            resetGame();
            update();
        }

        function resetGame() {
            player.y = canvas.height / 2;
            player.dy = 0;
            score = 0;
            distEl.innerText = score;
            speed = 5; // Depending on screen width you could scale speed, but 5 is fine
            obstacles = [];
            particles = [];
            frameCount = 0;
        }

        // --- Classes (Original Logic Intact) ---
        class Spike {
            constructor(x, isTop) {
                this.x = x; this.w = 30; this.h = 40; this.isTop = isTop;
                this.type = 'spike';
                this.color = isTop ? '#ff0055' : '#ff00ff';
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.beginPath();
                if (this.isTop) {
                    ctx.moveTo(this.x, WALL_HEIGHT);
                    ctx.lineTo(this.x + this.w, WALL_HEIGHT);
                    ctx.lineTo(this.x + this.w/2, WALL_HEIGHT + this.h);
                } else {
                    ctx.moveTo(this.x, canvas.height - WALL_HEIGHT);
                    ctx.lineTo(this.x + this.w, canvas.height - WALL_HEIGHT);
                    ctx.lineTo(this.x + this.w/2, canvas.height - WALL_HEIGHT - this.h);
                }
                ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0;
            }
            update() { this.x -= speed; }
        }

        class FloatingBlock {
            constructor(x) {
                this.x = x; this.w = 30; this.h = 30; this.type = 'block';
                // Random Y position in the middle safe zone
                this.y = Math.random() * (canvas.height - WALL_HEIGHT*2 - 100) + WALL_HEIGHT + 50;
                this.color = '#ffff00';
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.shadowBlur = 0;
            }
            update() { this.x -= speed; }
        }

        // --- Game Loop ---
        function update() {
            if (!gameActive || isPaused) return;

            player.dy = player.isHolding ? -speed : speed;
            player.y += player.dy;

            // Wall Sliding
            if (player.y < WALL_HEIGHT + player.size) player.y = WALL_HEIGHT + player.size;
            if (player.y > canvas.height - WALL_HEIGHT - player.size) player.y = canvas.height - WALL_HEIGHT - player.size;

            // Spawning Logic
            frameCount++;
            if (frameCount % 40 === 0) {
                const rand = Math.random();
                
                // --- 35% Chance Floating Block Logic Retained ---
                if (rand < 0.35) { 
                    obstacles.push(new FloatingBlock(canvas.width));
                } else {
                    obstacles.push(new Spike(canvas.width, rand > 0.65));
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.update();

                // Collision
                if (obs.type === 'spike') {
                    let tipY = obs.isTop ? WALL_HEIGHT + obs.h : canvas.height - WALL_HEIGHT - obs.h;
                    if (player.x + player.size > obs.x && player.x - player.size < obs.x + obs.w) {
                        if (obs.isTop && player.y - player.size < tipY) gameOver();
                        if (!obs.isTop && player.y + player.size > tipY) gameOver();
                    }
                } else if (obs.type === 'block') {
                    if (player.x + player.size > obs.x && player.x - player.size < obs.x + obs.w &&
                        player.y + player.size > obs.y && player.y - player.size < obs.y + obs.h) {
                        gameOver();
                    }
                }

                if (obs.x + obs.w < 0) {
                    obstacles.splice(i, 1);
                    score += 10;
                    distEl.innerText = score;
                    
                    // Sound par score hone par halka point sound 
                    // (Har point par sound annoying ho sakta hai, toh every 50 points par sound kar sakte ho)
                    if (score % 50 === 0) playSound('score');

                    // Speed increase every 200 points
                    if (score > 0 && score % 200 === 0) {
                        speed += 0.5;
                        playSound('score'); // extra point sound indicating level up
                    }
                }
            }

            particles.push({x: player.x, y: player.y});
            if(particles.length > 30) particles.shift();
            particles.forEach(p => p.x -= speed);

            draw();
            requestAnimationFrame(update);
        }

        function gameOver() {
            playSound('crash');
            gameActive = false;
            inputLocked = true; 
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('spaceWavesHighscore', highScore);
                highScoreEl.innerText = highScore;
            }

            mainTitle.innerText = "CRASHED!";
            mainTitle.style.color = "#ff0055";
            startMsg.style.display = 'none'; 
            restartMsg.style.display = 'none'; 
            overlay.style.display = 'flex';

            // 1 Second Lock
            setTimeout(() => {
                inputLocked = false; 
                restartMsg.style.display = 'block'; 
            }, 1000);
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Walls
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, WALL_HEIGHT);
            ctx.fillRect(0, canvas.height - WALL_HEIGHT, canvas.width, WALL_HEIGHT);
            
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, WALL_HEIGHT); ctx.lineTo(canvas.width, WALL_HEIGHT);
            ctx.moveTo(0, canvas.height - WALL_HEIGHT); ctx.lineTo(canvas.width, canvas.height - WALL_HEIGHT);
            ctx.stroke();

            // Trail
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            particles.forEach((p, i) => {
                if(i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            obstacles.forEach(obs => obs.draw());

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.isHolding ? -Math.PI/4 : Math.PI/4);
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(15, 0); ctx.lineTo(-10, -10); ctx.lineTo(-10, 10);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // Initial Draw
        draw(); 
    </script>
</body>
</html>